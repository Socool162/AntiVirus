==========================================================
YÊU CẦU BÀI TẬP: ANTIVIRUS ==========================================================

Xây dựng chương trình quét virus (Antivirus Scanner):
Yêu cầu:
- Nhận một thư mục đầu vào, duyệt toàn bộ các file PE trong đó.
- Với mỗi file, phân tích cấu trúc PE để:
	+ Phát hiện dấu hiệu nhiễm virus
	+ Ghi log (file/console) các file bị nhiễm (tên file, entrypoint).
	+ Bóc tách mã virus để trả về nguyên trạng file gốc. Lưu file sạch ra thư mục khác

- Tạo log (file/console) báo cáo kết quả sau khi quét:
	+ Tổng số file quét.
	+ Số file bị nhiễm.
	+ Số file bóc tách thành công.
Chương trình C/C++
Nâng cao: Bổ sung GUI hỗ trợ các chức năng (chọn folder, file đầu vào/đầu ra, hiển thị kết quả...)



==========================================================
**TÓM TẮT LUỒNG HOẠT ĐỘNG CỦA ANTIVIRUS**
==========================================================

Input thư mục cần quét (`Scanned Path`) và thư mục lưu file sạch (`Cleaned Path`)
Sau khi khởi tạo và mở file log, nó gọi hàm `scanDirectory`. 
Hàm `scanDirectory` duyệt đệ quy thư mục được chỉ định, lọc ra các file `.exe` và `.dll` 
Rồi chuyển từng file cho `processFile` xử lý. 

Hàm `processFile` đọc toàn bộ file vào buffer, phân tích cấu trúc PE, và thực hiện logic phát hiện: tìm một section tên là `.infect` và kiểm tra xem Entry Point của file có đang trỏ vào section đó không. 

Nếu phát hiện lây nhiễm, nó gọi hàm `disinfect` để "vá" lại file trong bộ đệm bằng cách đọc OEP gốc được virus cất giữ (tại offset `0x9F` so với đầu stub) và khôi phục OEP này về PE Header. 

Hàm `disinfect` cũng giảm `NumberOfSections` và xóa header của section `.infect`. 
Cuối cùng, `processFile` ghi lại bộ đệm đã được vá (với kích thước file đã được cắt bớt section virus) ra một file mới trong thư mục `Cleaned Path`.


==========================================================
CÁC HÀM CHÍNH CHI TIẾT
==========================================================

---
PHẦN 1: HÀM main - KHỞI TẠO VÀ ĐIỀU PHỐI
---
Hàm `main` đóng vai trò là "bộ điều khiển trung tâm", thiết lập môi trường và khởi động quá trình quét.

1.  **Nhận đầu vào (User Input):**
   In ra `Scanned Path:` và `Cleaned Path:`.
   Sử dụng `fgets` để đọc hai đường dẫn từ người dùng.
   Xóa ký tự `\n` ở cuối mỗi chuỗi nhập vào.
2.  **Thiết lập Môi trường (Environment Setup):**
   Gọi `CreateDirectoryA(outDir, NULL)` để đảm bảo thư mục chứa file sạch tồn tại.

3.  **Khởi tạo `ScannerState`:**
   Tạo một biến `state` kiểu `ScannerState` và khởi tạo tất cả thành viên bằng 0.
   Gán `state.outputDir = outDir`.
4.  **Mở Log File:**
   Gọi `fopen_s` để mở "scan_report.txt" ở chế độ ghi (`"w"`).
   Mọi output sau đó sẽ được `logMessage` ghi đồng thời vào console và file này.

5.  **Bắt đầu Quét (Initiate Scan):**
   `invoke logMessage, ... "Initializing..."`: Ghi lại các thông tin ban đầu (thư mục quét, thư mục output).
   `invoke scanDirectory, &state, scanDir`: Gọi hàm quét chính, bắt đầu từ thư mục gốc do người dùng cung cấp.
6.  **In Báo cáo (Final Report):**
   Sau khi `scanDirectory` hoàn thành (thoát khỏi đệ quy), `invoke printReport, &state` để in tổng kết (tổng số file quét, bị nhiễm, đã làm sạch).
7.  **Dọn dẹp:**
   `invoke fclose, state.logFile` để đóng file log.

---
PHẦN 2: HÀM scanDirectory - QUÉT THƯ MỤC ĐỆ QUY
---
1.  **Tạo đường dẫn tìm kiếm:**
   Tạo `searchPath` bằng cách nối thêm `\*` vào `dirPath` (ví dụ: `C:\test\*`).
2.  **Bắt đầu tìm kiếm:**
   `invoke FindFirstFileA, searchPath, &findData`: Tìm file/thư mục đầu tiên.
3.  **Vòng lặp `@@file_loop` (Sử dụng `do-while` với `FindNextFileA`):**
   Lặp qua tất cả các đối tượng trong thư mục.

4.  **Bộ lọc (Filtering):**
   Bỏ qua các thư mục `"."` và `".."` để tránh lặp vô hạn.
5.  **Xử lý Đệ quy (Recursion):**
   Kiểm tra `findData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY`.
   Nếu là một thư mục, `invoke scanDirectory, state, fullPath` (gọi lại chính nó với đường dẫn thư mục con).

6.  **Xử lý File (File Handling):**
   `invoke strrchr, findData.cFileName, '.'`: Tìm phần mở rộng của file.
   `invoke _stricmp, ext, ".exe"` và `_stricmp, ext, ".dll"`: Chỉ chọn các file PE thực thi.
   Nếu khớp, `invoke processFile, state, fullPath` để phân tích file này.
7.  **Kết thúc và Dọn dẹp:**
   `invoke FindClose, hFind` sau khi vòng lặp kết thúc.


---
PHẦN 3: HÀM processFile - PHÂN TÍCH, PHÁT HIỆN VÀ GHI FILE
---
1.  **Đọc File vào Buffer (File I/O):**
   `invoke fopen_s, filePath, "rb"`: Mở file ở chế độ đọc nhị phân.
   `invoke fseek/ftell`: Lấy kích thước file (`fileSize`).
   `invoke malloc, fileSize`: Cấp phát một buffer (`pFileBuffer`) trong bộ nhớ với kích thước bằng file.
   `invoke fread, pFileBuffer, ...`: Đọc *toàn bộ* nội dung file vào `pFileBuffer`.
   `invoke fclose, file`: Đóng file ngay lập tức.

2.  **Phân tích PE (PE Parsing):**
   Ép kiểu `pFileBuffer` thành `PIMAGE_DOS_HEADER`.
   Kiểm tra `dosHeader->e_magic == IMAGE_DOS_SIGNATURE` (Chữ ký "MZ").
   Ép kiểu `(pFileBuffer + dosHeader->e_lfanew)` thành `PIMAGE_NT_HEADERS`.
   Kiểm tra `ntHeaders->Signature == IMAGE_NT_SIGNATURE` (Chữ ký "PE\0\0").
   Kiểm tra `ntHeaders->OptionalHeader.Magic == IMAGE_NT_OPTIONAL_HDR32_MAGIC` (Là file PE 32-bit).
   Nếu bất kỳ kiểm tra nào thất bại, `goto cleanup` (bỏ qua file).

3.  **Detection Logic**
   Lấy `sectionHeader = IMAGE_FIRST_SECTION(ntHeaders)`.
   Lặp qua `ntHeaders->FileHeader.NumberOfSections`.
   **Signature 1 (Tên Section):** `invoke strncmp, sectionHeader[i].Name, VIRUS_SECTION_NAME` (so sánh với ".infect").
   **Signature 2 (Entry Point):** Kiểm tra `ntHeaders->OptionalHeader.AddressOfEntryPoint` có nằm trong dải RVA của section này không.
   Nếu cả 2 chữ ký đều đúng: Đánh dấu file bị nhiễm, lưu `infectedSection` và `infectedSectionIndex`.

4.  **Handle Infection**
   Nếu `infectedSection` được tìm thấy:
   Tăng `state->totalInfected`.
   `invoke disinfect, state, pFileBuffer, ntHeaders, infectedSection`

5.  **Save Clean File**
   Nếu `disinfect` trả về `1` (thành công):
   Tăng `state->totalCleaned`.
   Xây dựng `cleanPath` (đường dẫn file output).
   **Logic Cắt bỏ (Truncation):** Đây là bước quan trọng.
       Tìm section cuối cùng *trước* section bị nhiễm: `lastGoodSection = &sectionHeader[infectedSectionIndex - 1]`.
       Tính kích thước file mới: `newFileSize = lastGoodSection->PointerToRawData + lastGoodSection->SizeOfRawData`. (Kích thước này sẽ cắt bỏ section `.infect` ở cuối file).

   **Ghi File:**
       `invoke fopen_s, cleanPath, "wb"`: Mở file mới để ghi nhị phân.
       `invoke fwrite, pFileBuffer, 1, newFileSize, outFile`: Ghi `pFileBuffer` ra file mới, nhưng **chỉ ghi `newFileSize` bytes đầu tiên**.


---
PHẦN 4: HÀM disinfect - LOGIC KHỬ ĐỘC
---
Hàm này thực hiện việc "vá" lại PE Header trong bộ đệm (`pFileBuffer`), đảo ngược chính xác những gì virus đã làm.

1.  **Tìm vị trí lưu OEP:**
   Lấy `infected_EP_RVA` (đang trỏ vào section `.infect`).
   Tính `rvaOfOEPStorage = infected_EP_RVA + OFFSET_TO_OEP_STORAGE` (dùng hằng số `0x9F` bạn đã phân tích từ file `.lst` của virus).
2.  **Chuyển đổi RVA:**
   `invoke RvaToOffset, ntHeaders, rvaOfOEPStorage`: Gọi hàm tiện ích để lấy `fileOffset_OEP` (offset trên file, cũng là offset trong `pFileBuffer`)

3.  **Đọc OEP gốc:**
   `original_OEP = *(DWORD*)(pFileBuffer + fileOffset_OEP)`: Đọc 4-byte OEP gốc mà virus đã lưu tại vị trí đó trong stub.
4.  **Khôi phục OEP (Patching Header):**
   Ghi đè Entry Point của file về giá trị cũ: `ntHeaders->OptionalHeader.AddressOfEntryPoint = original_OEP`.

5.  **Xóa Section (Patching Header):**
   Giảm số lượng section: `ntHeaders->FileHeader.NumberOfSections--`.
   `invoke memset, infectedSection, 0, sizeof(IMAGE_SECTION_HEADER)`: Xóa trắng toàn bộ entry của section header `.infect` trong bộ đệm.
6.  **Trả về:** Trả về `1` (thành công) để `processFile` biết và tiến hành lưu file.




END!!!

